## 设计模式类型
设计模式分为三种类型,共23种
- 创建型模式
    - [单例模式](#单例模式)
    - [工厂模式](#工厂模式)
    - [抽象工厂模式](#抽象工厂模式)
    - [原型模式](#原型模式)
    - [建造者模式](#建造者模式)
- 结构型模式
    - [适配器模式](#适配器模式)
    - [桥接模式](#桥接模式)
    - [装饰模式](#装饰模式)
    - [组合模式](#组合模式)
    - [外观模式](#外观模式)
    - [享元模式](#享元模式)
    - [代理模式](#代理模式)
- 行为型模式
    - [模板方法模式](#模板方法模式)
    - [命令模式](#命令模式)
    - [访问者模式](#访问者模式)
    - [迭代器模式](#迭代器模式)
    - [观察者模式](#观察者模式)
    - [中介者模式](#中介者模式)
    - [备忘录模式](#备忘录模式)
    - [解释器模式](#解释器模式)
    - [状态模式](#状态模式)
    - [策略模式](#策略模式)
    - [职责链模式](#职责链模式)
    
### <a id="单例模式">一.单例模式</a>
&emsp;&emsp;单例设计模式,就是采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法\
&emsp;&emsp;比如Hibernate的SessionFactory,充当数据存储源的代理,并负责创建Session对象.SessionFactory并不是轻量级的,一个项目
只需要一个SessionFactory就够,因此需要用到单例模式.
#### 1 单例模式的八种方式
- 1.1 饿汉式-静态常量\
&emsp;&emsp;写法简单,在类装载的时候完成实例化,避免了线程同步问题\
&emsp;&emsp;在类装载的时候完成实例化,没有达到懒加载的效果.如果从始至终都没有使用过这个实例,会造成内存浪费\
&emsp;&emsp;这种方式基于classloder机制避免了多线程的同步问题,不过instance在类装载的时候就实例化,在单例模式中大多数都是
调用getInstance方法,但是导致类装载的原因有很多种,因此不能确定有其他的方式导致类装载,这时候初始化instance
没有达到懒加载效果.
- 1.2 饿汉式-静态代码块\
与静态变量类似,只是将类实例化的过程放在静态代码块中,优缺点一致
- 1.3 懒汉式-线程不安全\
&emsp;&emsp;1.起到了懒加载作用,但是只能单线程使用\
&emsp;&emsp;2.在多线程下有线程安全问题
- 1.4 懒汉式-线程安全,同步方法\
&emsp;&emsp;1.解决了线程不安全问题\
&emsp;&emsp;2.效率低,每个线程想要获得实例的时候,都要进行同步.其实这个方法只执行一次实例化代码就行了,方法进行同步效率太低
- 1.5 懒汉式-线程安全,同步代码块\
&emsp;&emsp;1.实际上是第四种方法的改进\
&emsp;&emsp;2.但是这种同步不能起到线程同步作用.如果线程进入判断语句,还没往下执行,另一个线程也通过这个判断语句,会有线程安全问题
- 1.6 双重检查\
&emsp;&emsp;1.double-check在多线程开发中经常用到\
&emsp;&emsp;2.线程安全,懒加载,效率高
- 1.7 静态内部类\
&emsp;&emsp;1.这种方式采用类装载机制来保证初始化实例时只有一个线程\
&emsp;&emsp;2.静态内部类在Singleton装载的时候不会立即实例化,耳屎在调用getInstance的时候才会装载\
&emsp;&emsp;3.类的静态属性只会第一次加载类的时候初始化,所以JVM保证了线程安全,在类初始化的时候,别的线程无法进入\
&emsp;&emsp;4.避免了线程不安全,利用静态内部类的特点实现了懒加载,效率高
- 1.8 枚举\
&emsp;&emsp;1.借助JDK1.5添加的枚举来实现单例,不仅能避免多线程同步问题,还可以防止反序列化重新创建新的对象\
&emsp;&emsp;2.这种方式是Effective Java作者提倡的方式
#### 2 JDK中的使用
- 2.1 Runtime
```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();
    public static Runtime getRuntime() {
        return currentRuntime;
    }
    private Runtime() {}
}
```
#### 单例模式注意事项和细节说明
1. 单例模式保证了系统内存该类只存在一个对象,节省了系统资源,对于一些需要频繁创建销毁的对象,使用单例模式可以提高系统性能
2. 当想要实例化一个单例类的时候,必须要记住相应的获取对象的方法,而不是使用new
3. 单例模式使用场景\
&nbsp;需要频繁的进行创建和销毁对象,创建对象时耗时过多或耗费资源过多(重量级对象),但是有经常用到的对象,工具类对象,频繁访问数据库或
文件的对象(数据源,session工厂等)

### <a id="工厂模式">二.工厂模式</a>
#### 2.1 简单工厂模式
##### 2.1.1 不使用简单工厂模式
![非简单工厂模式](./img/simplefactory1.png)
&emsp;&emsp;1.简单易操作\
&emsp;&emsp;2.缺点违反了设计模式ocp原则,对扩展开放,对修改关闭.当我们增加新功能时,尽量不修改代码,或者少修改代码.\
&emsp;&emsp;3.改进思路:\
&emsp;&emsp;&emsp;&emsp;将创建Pizza对象封装到一个类中,这样有新的Pizza种类的时候,只需要修改该类,其他创建Pizza对象代码就不需要修改
>相关代码:simplefactory.pizzastore
##### 2.1.2 简单工厂模式
![简单工厂模式](./img/simplefactory2.png)
1. 简单工厂模式属于创建型模式,是工厂模式的一种.简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例.简单工厂模式是工厂模式中最简单实用的模式
2. 简单工厂模式:定义了一个创建对象的类,由这个类来封装实例化对象的行为
3. 当我们会用到大量的创建某种,某类或者某批对象的时候,会用到工厂模式